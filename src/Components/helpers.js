import React, { Fragment, useCallback, useState } from 'react';
import PropTypes from 'prop-types';
import { Table, Thead, Tr, Th, Tbody, Td } from '@patternfly/react-table';
import {
  Dropdown,
  DropdownItem,
  DropdownList,
  Icon,
  MenuToggle,
  TextInput,
  TextInputGroup,
  TextInputGroupMain,
} from '@patternfly/react-core';
import { expandMatchMetadata } from './Common';
import { useVerifyInput } from './useVerifyInput';
import { CheckCircleIcon, InProgressIcon } from '@patternfly/react-icons';
import { EDIT_MATCH } from '../operations/mutations';
import { useMutation } from '@apollo/client';

export const filterValues = [
  { label: 'Not reviewed', value: 'NOT_REVIEWED' },
  { label: 'In review', value: 'IN_REVIEW' },
  { label: 'On-hold', value: 'ON_HOLD' },
  { label: 'Benign - not malicious malware', value: 'BENIGN' },
  { label: 'Malware detection test', value: 'TEST' },
  { label: 'No action - risk accepted', value: 'NO_ACTION' },
  { label: 'Resolved - malware removed', value: 'RESOLVED' },
];

export const matchStatusFilterMap = {
  NOT_REVIEWED: 'Not reviewed',
  IN_REVIEW: 'In review',
  ON_HOLD: 'On-hold',
  BENIGN: 'Benign - not malicious malware',
  TEST: 'Malware detection test',
  NO_ACTION: 'No action - risk accepted',
  RESOLVED: 'Resolved - malware removed',
};

function formatDate(inputDate) {
  const date = new Date(inputDate);

  const day = date.getUTCDate().toString().padStart(2, '0');
  const month = date.toLocaleString('default', { month: 'long' });
  const year = date.getUTCFullYear();

  return `${day}-${month}-${year}`;
}

export const TextInputGroupBasic = ({ status, id, initialValue }) => {
  const [value, setValue] = useState(initialValue);
  const [executeMutation] = useMutation(EDIT_MATCH);

  const memoizedExecuteMutation = useCallback(async () => {
    await executeMutation({
      variables: {
        input: {
          sourceHitId: id,
          status: status,
          justification: value,
        },
      },
    });
  }, [executeMutation, id, status, value]);

  const verifiedStatus = useVerifyInput(value, memoizedExecuteMutation);

  const isLoading = verifiedStatus === 'loading';

  return (
    <TextInputGroup>
      <TextInputGroupMain
        value={value}
        onChange={(_event, value) => setValue(value)}
      />
      <TextInput
        value={value}
        type="text"
        validated={!isLoading && verifiedStatus === 'error' && verifiedStatus}
        customIcon={
          (isLoading && <InProgressIcon />) ||
          (!isLoading && verifiedStatus === 'success' && <Icon status="success">
            <CheckCircleIcon />
          </Icon>)
        }
        onChange={(_event, value) => setValue(value)}
      />
    </TextInputGroup>
  );
};

TextInputGroupBasic.propTypes = {
  initialValue: PropTypes.string,
  status: PropTypes.string,
  id: PropTypes.number,
};

export const DropdownBasic = ({ initialValue }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [dropdownValue, setDropdownValue] = useState(initialValue);
  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const onSelect = (_event, value) => {
    setDropdownValue(value);
    setIsOpen(false);
  };

  return (
    <Dropdown
      isOpen={isOpen}
      onSelect={onSelect}
      onOpenChange={(isOpen) => setIsOpen(isOpen)}
      toggle={(toggleRef) => (
        <MenuToggle
          style={{ maxWidth: '75%' }}
          ref={toggleRef}
          onClick={onToggleClick}
          isExpanded={isOpen}
        >
          {filterValues.find((item) => item.value === dropdownValue)?.label}
        </MenuToggle>
      )}
      ouiaId="BasicDropdown"
    >
      <DropdownList>
        {filterValues.map((filterValue) => (
          <DropdownItem
            key={filterValue.value}
            component="button"
            onClick={(event) => onSelect(event, filterValue.value)}
          >
            {filterValue.label}
          </DropdownItem>
        ))}
      </DropdownList>
    </Dropdown>
  );
};

DropdownBasic.propTypes = {
  initialValue: PropTypes.any,
};

export const BasicTable = ({ hitlistData }) => {
  const columnNames = {
    scanDate: 'Dates matched',
    matchedStatus: 'Match status',
    note: 'Note',
  };

  return (
    <Fragment>
      <Table
        aria-label="Simple table"
        variant="compact"
        style={{ width: '100%', borderTop: '1px solid #d2d2d2' }}
      >
        <Thead style={{ borderBottom: '1px solid #d2d2d2' }}>
          <Tr>
            {Object.values(columnNames).map((column) => (
              <Th key={column}>{column}</Th>
            ))}
          </Tr>
        </Thead>
        <Tbody>
          {hitlistData?.map((data) => (
            <Tr key={data.id}>
              <Td dataLabel={columnNames.scanDate}>
                {formatDate(data.scanDate)}
              </Td>
              <Td style={{ maxWidth: '100px' }}>
                <DropdownBasic initialValue={data.status} />
              </Td>
              <Td>
                <TextInputGroupBasic
                  status={data.status}
                  id={data.id}
                  initialValue={data.justification}
                />
              </Td>
            </Tr>
          ))}
        </Tbody>
      </Table>
    </Fragment>
  );
};

BasicTable.propTypes = {
  hitlistData: PropTypes.any,
};

export const generateCode = (host) => {
  if (!host || !host.matches) {
    throw new Error('Host or host.matches is not defined');
  }

  return host.matches
    .map(
      (match, key) => `Match Source: ${match.source}
Offset: ${match.stringOffset}
Match Data: ${match.stringData}
Match Identifier: ${match.stringIdentifier}
Match Scan Date: ${new Date(match.scanDate).toUTCString()}
${
  match.metadata
    ? expandMatchMetadata(JSON.parse(match.metadata.replaceAll('\n', '')))
    : ''
}
${
  host.matches.length > 1 && key !== host.matches.length - 1
    ? '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
    : ''
}`
    )
    .join('\n');
};
