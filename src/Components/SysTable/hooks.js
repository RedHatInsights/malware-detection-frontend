import { useApolloClient } from '@apollo/client';
import { useCallback } from 'react';
import { useEffect, useLayoutEffect } from 'react';
import { useDispatch } from 'react-redux';
// import debounce from 'lodash/debounce';

export const useInventoryUtilities = (
    inventory
    // selectedSystems,
    // activeFilters
) => {
    const dispatch = useDispatch();

    // Resets the Inventory to a loading state
    // and prevents previously shown columns and rows to appear
    useLayoutEffect(() => {
        dispatch({
            type: 'INVENTORY_INIT'
        });
    }, []);

    // Ensures rows are marked as selected
    // useEffect(() => {
    //     dispatch({
    //         type: 'SELECT_ENTITIES',
    //         payload: {
    //             selected: selectedSystems
    //         }
    //     });
    // }, [selectedSystems]);

    // Filters do not yet trigger the inventory to call getEntities
    // and the page would not reset to page 1
    const resetPage = () => {
        Promise.resolve(
            dispatch({
                type: 'RESET_PAGE'
            })
        ).then(() => inventory?.current?.onRefreshData());
    };

    // The debounce is to not have filter updates collide or get out of order.
    // const debounceResetPage = debounce(resetPage, 50);

    useEffect(() => {
        resetPage();
    }, []);
};

const buildApiFilters = (filters = {}) => {
    const { tagFilters, ...otherFilters } = filters;
    const tagsApiFilter = tagFilters
        ? {
            tags: tagFilters.flatMap((tagFilter) =>
                tagFilter.values.map(
                    (tag) =>
                        `${encodeURIComponent(tagFilter.key)}/${encodeURIComponent(
                            tag.tagKey
                        )}=${encodeURIComponent(tag.value)}`
                )
            )
        }
        : {};

    return {
        ...otherFilters,
        ...tagsApiFilter
    };
};

const renameInventoryAttributes = ({
    culledTimestamp,
    staleWarningTimestamp,
    staleTimestamp,
    insightsId,
    lastScanned,
    ...system
}) => ({
    ...system,
    updated: lastScanned,
    culled_timestamp: culledTimestamp,
    stale_warning_timestamp: staleWarningTimestamp,
    stale_timestamp: staleTimestamp,
    insights_id: insightsId
});

export const profilesRulesFailed = (profiles) =>
    profiles.flatMap(
        (profile) =>
            profile.rules && profile.rules.filter((rule) => !rule.compliant)
    );

export const systemRulesFailed = (system) =>
    system.testResultProfiles
        ? profilesRulesFailed(system.testResultProfiles)
        : [];

export const systemSupportedByProfiles = (profiles = []) =>
    profiles.reduce((acc, profile) => acc && !!profile.supported, true);

export const systemsWithRuleObjectsFailed = (systems) =>
    systems.map((system) => ({
        ...system,
        ruleObjectsFailed: systemRulesFailed(system),
        supported: systemSupportedByProfiles(system.testResultProfiles),
        profiles: system.testResultProfiles
    }));

export const useFetchSystems = ({
    query,
    onComplete,
    variables = {},
    onError
}) => {
    const client = useApolloClient();

    return (perPage, page, requestVariables = {}) =>
        client
        .query({
            query,
            fetchResults: true,
            fetchPolicy: 'no-cache',
            variables: {
                perPage,
                page,
                ...variables,
                ...requestVariables
            }
        })
        .then(({ data }) => {
            const systems = data?.hostsList || [];
            const entities = systemsWithRuleObjectsFailed(systems).map(
                renameInventoryAttributes
            );
            const result = {
                entities,
                meta: {
                    ...(requestVariables.tags && { tags: requestVariables.tags }),
                    totalCount: data?.hosts?.totalCount || 0
                }
            };

            onComplete && onComplete(result);
            return result;
        })
        .catch((error) => {
            if (onError) {
                onError(error);
                return { entities: [], meta: { totalCount: 0 } };
            } else {
                throw error;
            }
        });
};

export const useGetEntities = (fetchEntities, { selected, columns } = {}) => {
    const appendDirection = useCallback((attributes, direction) =>
        attributes.map((attribute) => `${attribute}:${direction}`), []);

    const findColumnByKey = useCallback((key) =>
        (columns || []).find((column) => column.key === key), [columns]);

    return useCallback(async (
        _ids,
        { page = 1, per_page: perPage, orderBy, orderDirection, filters }
    ) => {
        const sortableColumn = findColumnByKey(orderBy);
        const sortBy =
        sortableColumn && sortableColumn.sortBy
            ? appendDirection(sortableColumn.sortBy, orderDirection)
            : undefined;
        const filterForApi = buildApiFilters(filters);

        const fetchedEntities = await fetchEntities(perPage, page, {
            ...filterForApi,
            sortBy
        });
        const {
            entities,
            meta: { totalCount }
        } = fetchedEntities || {};

        return {
            results: entities.map((entity) => ({
                ...entity,
                selected: (selected || []).map((id) => id).includes(entity.id)
            })),
            orderBy,
            orderDirection,
            total: totalCount
        };
    }, []);
};
