import { Pagination, PaginationVariant } from '@patternfly/react-core/dist/esm/components/Pagination';
import React, { useEffect, useReducer } from 'react';
import {
    SortByDirection,
    Table,
    TableBody,
    TableHeader,
    cellWidth,
    expandable,
    sortable,
    info,
    classNames
} from '@patternfly/react-table/dist/esm/components/Table';

import CheckCircleIcon from '@patternfly/react-icons/dist/esm/icons/check-circle-icon';
import CodeEditor from '../CodeEditor/CodeEditor';
import { DateFormat } from '@redhat-cloud-services/frontend-components/DateFormat';
import { expandMatchMetadata } from '../Common';
import { GET_SIGNATURE_DETAILS_TABLE, GET_SIGNATURE_DETAILS_TABLE_GROUPS } from '../../operations/queries';
import MessageState from '../MessageState/MessageState';
import { PrimaryToolbar } from '@redhat-cloud-services/frontend-components/PrimaryToolbar';
import { SearchIcon } from '@patternfly/react-icons/dist/esm/icons/search-icon';
import messages from '../../Messages';
import propTypes from 'prop-types';
import { useIntl } from 'react-intl';
import { useQuery } from '@apollo/client';
import EmptyAccount from '../SharedComponents/EmptyAccount';
import InsightsLink from '@redhat-cloud-services/frontend-components/InsightsLink';
import { SkeletonTable } from '@redhat-cloud-services/frontend-components/SkeletonTable';
import { isEmpty, uniqWith } from 'lodash';

const sortIndices = { 1: 'DISPLAY_NAME', 2: 'GROUPS', 3: 'OS_VERSION', 4: 'LAST_SCAN_DATE', 5: 'MATCH_COUNT' };
const orderBy = ({ index, direction }) => `${sortIndices[index]}_${direction === SortByDirection.asc ? 'ASC' : 'DESC'}`;

const tableReducer = (state, action) => {
    switch (action.type) {
        case 'setTableVars':
            return { ...state, tableVars: { ...state.tableVars, ...action.payload } };
        case 'setSortBy':
            return { ...state, sortBy: action.payload, tableVars: { ...state.tableVars, ...action.tableVars } };
        case 'setRows':
            return { ...state, rows: action.payload };
        case 'setGroups':
            return { ...state, groups: action.payload };
    }

    return state;
};

const SigDetailsTable = ({ ruleName, affectedCount, isEmptyAccount }) => {
    const intl = useIntl();
    const initialState = {
        tableVars: {
            limit: 10,
            offset: 0,
            orderBy: 'LAST_SCAN_DATE_DESC',
            displayName: '',
            condition: {},
            ruleName
        },
        sortBy: {
            index: 4,
            direction: SortByDirection.desc
        },
        rows: [],
        groups: []
    };
    const [{ tableVars, sortBy, rows, groups }, stateSet] = useReducer(tableReducer, {
        ...initialState
    });
    const { data, loading, error } =
        useQuery(GET_SIGNATURE_DETAILS_TABLE, { variables: tableVars });
    const { data: groupData } =
        useQuery(GET_SIGNATURE_DETAILS_TABLE_GROUPS, { variables: { ruleName } });
    const columns = [
        { title: intl.formatMessage(messages.name), cellFormatters: [expandable], transforms: [sortable, cellWidth(45)] },
        { title: intl.formatMessage(messages.group), transforms: [sortable, cellWidth(15)] },
        { title: intl.formatMessage(messages.os), key: 'osVersion', transforms: [sortable, cellWidth(10)] },
        { title: intl.formatMessage(messages.lastMatched), transforms: [sortable, cellWidth(10)] },
        {
            title: intl.formatMessage(messages.totalMatches),
            transforms: [
                info({
                    tooltip: intl.formatMessage(messages.totalMatchesNote)
                }),
                sortable, cellWidth(10)
            ]
        }
    ];

    const page = tableVars.offset / tableVars.limit + 1;

    const filterConfigItems = [{
        label: intl.formatMessage(messages.name).toLowerCase(),
        filterValues: {
            key: 'text-filter',
            onChange: (e, value) => stateSet({ type: 'setTableVars', payload: { displayName: value, offset: 0 } }),
            value: tableVars.displayName,
            placeholder: intl.formatMessage(messages.filterBy, { field: intl.formatMessage(messages.name).toLowerCase() })
        }
    }, {
        label: intl.formatMessage(messages.group).toLowerCase(),
        type: 'checkbox',
        filterValues: {
            key: 'group-filter',
            onChange: (e, value) => {
                // Sets the group condition used in the GET_SIGNATURE_DETAILS_TABLE query
                const condition = isEmpty(value) ? {} : { groups: value.map(item => JSON.parse(item)) };
                stateSet({ type: 'setTableVars', payload: { condition }, offset: 0 });
            },
            items: groups,
            value: tableVars.condition?.groups ? tableVars.condition.groups.map(group => JSON.stringify(group)) : [],
            placeholder: intl.formatMessage(messages.filterBy, { field: intl.formatMessage(messages.group).toLowerCase() })
        }
    }];

    const onSetPage = (e, page) => stateSet({ type: 'setTableVars', payload: { offset: page * tableVars.limit - tableVars.limit } });

    const onPerPageSelect = (e, perPage) => stateSet({ type: 'setTableVars', payload: { limit: perPage, offset: 0 } });

    const onSort = (e, index, direction) =>
        stateSet({ type: 'setSortBy', payload: { index, direction }, tableVars: { orderBy: orderBy({ index, direction }), offset: 0 } });

    const onCollapse = (e, rowKey, isOpen) => {
        const collapseRows = [...rows];
        const host = collapseRows[rowKey + 1].hostData;

        collapseRows[rowKey] = { ...collapseRows[rowKey], isOpen };
        collapseRows[rowKey + 1].cells = [{
            title: <CodeEditor height='250px' code={`${host.matches.map((match, key) => `Match Source: ${match.source}
Offset:${match.stringOffset}
Match Data: ${match.stringData}
Match Identifier: ${match.stringIdentifier}
Match Scan Date: ${new Date(match.scanDate).toUTCString()}
${match.metadata ? expandMatchMetadata(JSON.parse(match.metadata)) : ''}
${host.matches.length > 1 && key !== host.matches.length - 1 ? `~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
` : ''}`).join('')}`}
            isDownloadEnabled isCopyEnabled />
        }];
        stateSet({ type: 'setRows', payload: collapseRows });
    };

    useEffect(() => {
        const rowBuilder = data => data?.flatMap((data, key) => {
            const host = data;
            return [{
                rowId: key,
                isOpen: false,
                cells: [
                    { title: <InsightsLink to={`/systems/${host.id}`}>{host.displayName}</InsightsLink> },
                    { title: `${host.groups?.[0]?.name || 'N/A'}` },
                    { title: `RHEL ${host.osVersion || 'Unavailable'}` },
                    { title: <DateFormat date={new Date(host.matches[host.matches.length - 1].scanDate)} type='onlyDate' /> },
                    { title: <InsightsLink to={`/systems/${host.id}`}>{host.matchCount?.toLocaleString()}</InsightsLink> }
                ]
            }, {
                parent: key * 2,
                hostData: host,
                fullWidth: true,
                cells: []
            }];
        });

        stateSet({ type: 'setRows', payload: rowBuilder(data?.rulesList[0]?.affectedHostsList) });
    }, [intl, data]);

    useEffect(() => {
        // populates the Group filter list
        const getGroupList = groupData => {
            return groupData?.filter(host => !isEmpty(host.groups)).map(host => {
                const group = host.groups[0];
                return {
                    label: group.name,
                    value: JSON.stringify({ id: group.id, name: group.name })
                };
            });
        };

        let groupsList = getGroupList(groupData?.rulesList[0]?.affectedHostsList) || [];
        groupsList = uniqWith(groupsList, (group1, group2) => group1.label === group2.label);
        stateSet({ type: 'setGroups', payload: groupsList });
    }, [groupData]);

    const NoResultsMatch = (
        <MessageState className='pf-c-card' icon={SearchIcon} variant='large' title={intl.formatMessage(messages.noResults)}
            text={intl.formatMessage(messages.noResultsMatch)} />
    );

    const NoAffectedHosts = (
        <MessageState className='pf-c-card' variant='large' icon={CheckCircleIcon} iconClass='ins-l-success-color'
            title={intl.formatMessage(messages.noAffectedHosts)}
            text={intl.formatMessage(messages.noAffectedHostsBody)} />
    );

    const EmptyAccountState = (
        <EmptyAccount className='pf-c-card' message={intl.formatMessage(messages.emptyAccountTableBody)} />
    );

    const ErrorState = (
        <MessageState className='pf-c-card' variant='large' title='Error' text='error' />
    );

    const buildFilterChips = () => {
        const chips = [];
        tableVars?.displayName &&
            chips.push({
                category: intl.formatMessage(messages.name), value: 'name',
                chips: [{ name: tableVars?.displayName, value: tableVars?.displayName }]
            });
        !isEmpty(tableVars?.condition) &&
            chips.push({
                category: intl.formatMessage(messages.group), value: 'groups',
                chips: tableVars.condition.groups.map(group => ({ name: group.name, value: group.name }))
            });
        return chips;
    };

    const activeFiltersConfig = {
        deleteTitle: intl.formatMessage(messages.resetFilters),
        filters: buildFilterChips(),
        showDeleteButton: tableVars?.displayName !== '' || !isEmpty(tableVars?.condition),
        onDelete: (event, itemsToRemove, isAll) => {
            if (isAll) {
                stateSet({ type: 'setTableVars', payload: { displayName: '', condition: {}, offset: 0 } });
            } else {
                itemsToRemove.map((item) => {
                    item.value === 'name' && stateSet({ type: 'setTableVars', payload: { displayName: '' } });
                    if (item.value === 'groups') {
                        const groups = tableVars.condition.groups.filter(group => group.name !== item.chips[0].name);
                        const payload = groups.length ? { condition: { groups } } : { condition: {} };
                        stateSet({ type: 'setTableVars', payload });
                    }
                });
            }
        }
    };

    return <React.Fragment>
        <PrimaryToolbar
            pagination={{
                itemCount: data?.rulesList[0]?.affectedHosts?.totalCount || 0,
                page,
                perPage: tableVars.limit,
                onSetPage(e, page) { onSetPage(e, page); },
                onPerPageSelect(e, perPage) { onPerPageSelect(e, perPage); },
                isCompact: true
            }}
            filterConfig={{ items: filterConfigItems }}
            activeFiltersConfig={activeFiltersConfig}
        />
        {loading
            ? <SkeletonTable
                columns={[{ title: '', columnTransforms: [classNames('skeleton-expandable-column')] }, ...columns]}
                rowSize={tableVars.limit}
                sortBy={sortBy}
            />
            : <Table
                className='sigTable'
                aria-label='Signature Details table'
                rows={rows}
                cells={columns}
                onCollapse={onCollapse}
                onSort={onSort}
                sortBy={data?.rulesList[0]?.affectedHosts?.totalCount > 0 ? sortBy : undefined}
                isStickyHeader
            >
                <TableHeader />
                <TableBody />
            </Table>}

        {
            (!error && !loading && affectedCount !== 0)
                ? (data?.rulesList[0]?.affectedHosts?.totalCount === 0)
                    ? NoResultsMatch : <React.Fragment />
                : (!loading &&
                    (isEmptyAccount ? EmptyAccountState : NoAffectedHosts)
                )
        }
        {error && <ErrorState />}
        <Pagination
            itemCount={data?.rulesList[0]?.affectedHosts?.totalCount || 0}
            widgetId='pagination-options-menu-bottom'
            perPage={tableVars.limit}
            page={page}
            variant={PaginationVariant.bottom}
            onSetPage={onSetPage}
            onPerPageSelect={onPerPageSelect}
        />
    </React.Fragment>;
};

SigDetailsTable.propTypes = {
    ruleName: propTypes.string,
    affectedCount: propTypes.number,
    isEmptyAccount: propTypes.bool
};

export default SigDetailsTable;
