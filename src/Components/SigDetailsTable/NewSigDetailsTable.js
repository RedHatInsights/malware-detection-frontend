import React, { useEffect, useReducer, useState } from 'react';
import propTypes from 'prop-types';
import { useIntl } from 'react-intl';
import { useApolloClient } from '@apollo/client';
import { isEmpty, uniqWith } from 'lodash';
import { Icon, Pagination, PaginationVariant } from '@patternfly/react-core';
import {
  Table,
  TableBody,
  TableHeader,
} from '@patternfly/react-table/deprecated';
import { SortByDirection } from '@patternfly/react-table';
import { BellIcon, CheckCircleIcon, SearchIcon } from '@patternfly/react-icons';
import InsightsLink from '@redhat-cloud-services/frontend-components/InsightsLink';
import { SkeletonTable } from '@patternfly/react-component-groups';
import { PrimaryToolbar } from '@redhat-cloud-services/frontend-components/PrimaryToolbar';
import TableToolbar from '@redhat-cloud-services/frontend-components/TableToolbar';
import { DateFormat } from '@redhat-cloud-services/frontend-components/DateFormat';
import {
  GET_SIGNATURE_DETAILS_TABLE,
  GET_SIGNATURE_DETAILS_TABLE_GROUPS,
} from '../../operations/queries';
import CodeEditor from '../CodeEditor/CodeEditor';
import MessageState from '../MessageState/MessageState';
import messages from '../../Messages';
import EmptyAccount from '../SharedComponents/EmptyAccount';
import './SigDetailsTable.scss';
import { useWorkspaceFeatureFlag } from '../../Utilities/Hooks';
import { generateCode, matchStatusFilterMap, updateArray } from '../helpers';
import { sigDetailsTableColumns } from './Columns';
import { useActionsConfig } from '../../Utilities/Hooks';
import { filterValues } from '../constants';
import { NewMatchesTable } from '../TableComponents/NewMatchesTable';

const sortIndices = {
  1: 'DISPLAY_NAME',
  2: 'GROUP_NAME',
  3: 'OS_VERSION',
  4: 'LAST_SCAN_DATE',
  5: 'NEW_MATCH_COUNT',
  6: 'MATCH_COUNT',
};

const orderBy = ({ index, direction }) =>
  `${sortIndices[index]}_${direction === SortByDirection.asc ? 'ASC' : 'DESC'}`;

const tableReducer = (state, action) => {
  switch (action.type) {
    case 'setTableVars':
      return { ...state, tableVars: { ...state.tableVars, ...action.payload } };
    case 'setSortBy':
      return {
        ...state,
        sortBy: action.payload,
        tableVars: { ...state.tableVars, ...action.tableVars },
      };
    case 'setRows':
      return { ...state, rows: action.payload };
    case 'setGroups':
      return { ...state, groups: action.payload };
  }

  return state;
};

const NewSigDetailsTable = ({ ruleName, affectedCount, isEmptyAccount }) => {
  const intl = useIntl();
  const client = useApolloClient();
  const isWorkspaceEnabled = useWorkspaceFeatureFlag();
  const [selectedMatches, setSelectedMatches] = useState([]);
  const [sigDetailsTableLoading, setSigDetailsTableLoading] = useState(false);
  const [sigDetailsTable, setSigDetailsTable] = useState({});
  const [sigDetailsTableGroupsLoading, setSigDetailsTableGroupsLoading] =
    useState(false);
  const [sigDetailsTableGroups, setSigDetailsTableGroups] = useState({});
  const [expandedRows, setExpandedRows] = useState([]);

  const initialState = {
    tableVars: {
      limit: 10,
      offset: 0,
      orderBy: 'LAST_SCAN_DATE_DESC',
      displayName: '',
      hostGroupFilter: undefined,
      sigMatchStatusFilter: undefined,
      ruleName,
    },
    sortBy: {
      index: 4,
      direction: SortByDirection.desc,
    },
    rows: [],
    groups: [],
  };

  const [{ tableVars, sortBy, rows, groups }, stateSet] = useReducer(
    tableReducer,
    {
      ...initialState,
    }
  );

  const fetchDetailsTable = async (shouldShowLoading) => {
    if (shouldShowLoading) {
      setSigDetailsTableLoading(true);
    }

    let response;
    try {
      response = await client.query({
        query: GET_SIGNATURE_DETAILS_TABLE,
        fetchPolicy: 'no-cache',
        variables: tableVars,
      });
    } catch (error) {
      console.error('Error fetching data:', error);
    }

    setSigDetailsTableLoading(false);
    setSigDetailsTable(response);
  };

  const fetchDetailsTableGroups = async (shouldShowLoading) => {
    if (shouldShowLoading) {
      setSigDetailsTableGroupsLoading(true);
    }

    let response;
    try {
      response = await client.query({
        query: GET_SIGNATURE_DETAILS_TABLE_GROUPS,
        fetchPolicy: 'no-cache',
        variables: tableVars,
      });
    } catch (error) {
      console.error('Error fetching data:', error);
    }

    setSigDetailsTableGroupsLoading(false);
    setSigDetailsTableGroups(response);
  };

  useEffect(() => {
    fetchDetailsTable();
    fetchDetailsTableGroups();
  }, []);

  const page = tableVars.offset / tableVars.limit + 1;
  const columns = sigDetailsTableColumns(isWorkspaceEnabled, intl);

  const filterConfigItems = (isWorkspaceEnabled) => [
    {
      label: intl.formatMessage(messages.name).toLowerCase(),
      type: 'text',
      filterValues: {
        key: 'text-filter',
        onChange: (e, value) =>
          stateSet({
            type: 'setTableVars',
            payload: { displayName: value, offset: 0 },
          }),
        value: tableVars.displayName,
        placeholder: intl.formatMessage(messages.filterBy, {
          field: intl.formatMessage(messages.name).toLowerCase(),
        }),
      },
    },
    {
      label: isWorkspaceEnabled
        ? 'Workspace'
        : intl.formatMessage(messages.group).toLowerCase(),
      type: isEmpty(groups) ? 'group' : 'checkbox', // display checkboxes only if there are groups to choose from
      filterValues: {
        key: 'group-filter',
        onChange: (e, value) => {
          // Populates hostGroupFilter used in the GET_SIGNATURE_DETAILS_TABLE query
          stateSet({
            type: 'setTableVars',
            payload: { hostGroupFilter: value },
            offset: 0,
          });
        },
        items: sigDetailsTableGroupsLoading
          ? [] // display an empty box whilst the groups are loading
          : isEmpty(groups)
          ? [
              {
                isDisabled: true,
                label: isWorkspaceEnabled
                  ? 'No workspace to filter'
                  : intl.formatMessage(messages.noGroups),
              },
            ] // message if no groups
          : groups,
        value: tableVars.hostGroupFilter,
        placeholder: isWorkspaceEnabled
          ? 'Filter by workspace'
          : intl.formatMessage(messages.filterBy, {
              field: intl.formatMessage(messages.group).toLowerCase(),
            }),
      },
    },
    {
      label: intl.formatMessage(messages.sigMatchStatus).toLowerCase(),
      type: 'checkbox',
      filterValues: {
        key: 'sig-match-status-filter',
        onChange: (e, value) => {
          stateSet({
            type: 'setTableVars',
            payload: { sigMatchStatusFilter: value },
            offset: 0,
          });
        },
        items: filterValues,
        value: tableVars.sigMatchStatusFilter,
        placeholder: intl.formatMessage(messages.filterBy, {
          field: intl.formatMessage(messages.status).toLowerCase(),
        }),
      },
    },
  ];

  const onSetPage = (e, page) =>
    stateSet({
      type: 'setTableVars',
      payload: { offset: page * tableVars.limit - tableVars.limit },
    });

  const onPerPageSelect = (e, perPage) =>
    stateSet({ type: 'setTableVars', payload: { limit: perPage, offset: 0 } });

  const onSort = (e, index, direction) =>
    stateSet({
      type: 'setSortBy',
      payload: { index, direction },
      tableVars: { orderBy: orderBy({ index, direction }), offset: 0 },
    });

  const actions = useActionsConfig(
    selectedMatches,
    fetchDetailsTable,
    fetchDetailsTableGroups
  );

  const getExpandedCells = (host) => {
    return [
      {
        title: (
          <div>
            <NewMatchesTable
              fetchDetailsTable={fetchDetailsTable}
              hostId={host.id}
              ruleName={tableVars.ruleName}
              setSelectedMatches={setSelectedMatches}
              matchStatusFilter={tableVars.sigMatchStatusFilter}
            />
            <CodeEditor
              height="250px"
              code={generateCode(host)}
              isDownloadEnabled
              isCopyEnabled
            />
          </div>
        ),
      },
    ];
  };

  const onCollapse = async (e, rowKey, isOpen) => {
    const collapseRows = [...rows];
    const host = collapseRows[rowKey + 1].hostData;

    collapseRows[rowKey] = { ...collapseRows[rowKey], isOpen };

    setExpandedRows((prev) => {
      return updateArray(prev, rowKey);
    });

    collapseRows[rowKey + 1].cells = getExpandedCells(host);

    stateSet({ type: 'setRows', payload: collapseRows });
  };

  useEffect(() => {
    const rowBuilder = (data) =>
      data?.flatMap((data, key) => {
        const host = data;
        return [
          {
            rowId: key,
            isOpen: expandedRows.includes(key * 2) ? true : false,
            cells: [
              {
                title: (
                  <InsightsLink to={`/systems/${host.id}`}>
                    {host.displayName}
                  </InsightsLink>
                ),
              },
              {
                title: `${
                  host.groups?.[0]?.name ||
                  intl.formatMessage(messages.notApplicable)
                }`,
              },
              {
                title: host.osVersion
                  ? `RHEL ${host.osVersion}`
                  : intl.formatMessage(messages.dataNotAvailable),
              },
              {
                title: (
                  <DateFormat
                    date={
                      new Date(host.matches[host.matches.length - 1].scanDate)
                    }
                    type="onlyDate"
                  />
                ),
              },
              {
                title: (
                  <span>
                    {host.newMatchCount ? (
                      <Icon style={{ marginRight: '8px' }}>
                        <BellIcon />
                      </Icon>
                    ) : null}
                    {host.newMatchCount?.toLocaleString()}
                  </span>
                ),
              },
              {
                title: (
                  <InsightsLink to={`/systems/${host.id}`}>
                    {host.matchCount?.toLocaleString()}
                  </InsightsLink>
                ),
              },
            ],
          },
          {
            parent: key * 2,
            hostData: host,
            fullWidth: true,
            cells: expandedRows.includes(key * 2) ? getExpandedCells(host) : [],
          },
        ];
      });

    stateSet({
      type: 'setRows',
      payload: rowBuilder(
        sigDetailsTable?.data?.rulesList[0]?.affectedHostsList
      ),
    });
  }, [intl, sigDetailsTable.data]);

  useEffect(() => {
    // populates the Group name filter dropdown
    const getGroupList = (groupsData) => {
      return groupsData
        ?.filter((host) => !isEmpty(host.groups))
        .map((host) => ({
          label: host.groups[0].name,
          value: host.groups[0].name,
        }));
    };

    let groupsList =
      getGroupList(
        sigDetailsTableGroups?.data?.rulesList[0]?.affectedHostsList
      ) || [];
    groupsList = uniqWith(
      groupsList,
      (group1, group2) => group1.label === group2.label
    ); // remove duplicate group names
    stateSet({ type: 'setGroups', payload: groupsList });
  }, [sigDetailsTableGroups?.data]);

  const NoResultsMatch = (
    <MessageState
      className="pf-c-card"
      icon={SearchIcon}
      variant="large"
      title={intl.formatMessage(messages.noResults)}
      text={intl.formatMessage(messages.noResultsMatch)}
    />
  );

  const NoAffectedHosts = (
    <MessageState
      className="pf-c-card"
      variant="large"
      icon={CheckCircleIcon}
      iconClass="ins-l-success-color"
      title={intl.formatMessage(messages.noAffectedHosts)}
      text={intl.formatMessage(messages.noAffectedHostsBody)}
    />
  );

  const EmptyAccountState = (
    <EmptyAccount
      className="pf-c-card"
      message={intl.formatMessage(messages.emptyAccountTableBody)}
    />
  );

  const ErrorState = () => (
    <MessageState
      className="pf-c-card"
      variant="large"
      title="Error"
      text="error"
    />
  );

  const buildFilterChips = () => {
    const chips = [];
    tableVars?.displayName &&
      chips.push({
        category: intl.formatMessage(messages.name),
        value: 'name',
        chips: [
          { name: tableVars?.displayName, value: tableVars?.displayName },
        ],
      });
    tableVars?.hostGroupFilter &&
      chips.push({
        category: intl.formatMessage(messages.group),
        value: 'groups',
        chips: tableVars.hostGroupFilter.map((group) => ({
          name: group,
          value: group,
        })),
      });
    tableVars?.sigMatchStatusFilter &&
      chips.push({
        category: intl.formatMessage(messages.status),
        value: 'status',
        chips: tableVars.sigMatchStatusFilter.map((status) => ({
          name: matchStatusFilterMap[status],
          value: status,
        })),
      });
    return chips;
  };

  const activeFiltersConfig = {
    deleteTitle: intl.formatMessage(messages.resetFilters),
    filters: buildFilterChips(),
    showDeleteButton:
      tableVars?.displayName !== '' ||
      tableVars?.hostGroupFilter !== undefined ||
      tableVars?.sigMatchStatusFilter !== undefined,
    onDelete: (event, itemsToRemove, isAll) => {
      if (isAll) {
        stateSet({
          type: 'setTableVars',
          payload: {
            displayName: '',
            hostGroupFilter: undefined,
            sigMatchStatusFilter: undefined,
            offset: 0,
          },
        });
      } else {
        itemsToRemove.map((item) => {
          item.value === 'name' &&
            stateSet({ type: 'setTableVars', payload: { displayName: '' } });
          if (item.value === 'groups') {
            const groupChips = tableVars.hostGroupFilter.filter(
              (group) => group !== item.chips[0].name
            );
            const payload = {
              hostGroupFilter: groupChips.length ? groupChips : undefined,
              offset: 0,
            };
            stateSet({ type: 'setTableVars', payload });
          } else if (item.value === 'status') {
            const sigMatchStatusChips = tableVars.sigMatchStatusFilter.filter(
              (status) => status !== item.chips[0].value
            );
            const payload = {
              sigMatchStatusFilter: sigMatchStatusChips.length
                ? sigMatchStatusChips
                : undefined,
              offset: 0,
            };
            stateSet({ type: 'setTableVars', payload });
          }
        });
      }
    },
  };

  return (
    <React.Fragment>
      <PrimaryToolbar
        actionsConfig={{
          dropdownProps: { popperProps: { position: 'left' } },
          actions,
        }}
        pagination={{
          itemCount:
            sigDetailsTable?.data?.rulesList[0]?.affectedHosts?.totalCount || 0,
          page,
          perPage: tableVars.limit,
          onSetPage(e, page) {
            onSetPage(e, page);
          },
          onPerPageSelect(e, perPage) {
            onPerPageSelect(e, perPage);
          },
          isCompact: true,
        }}
        filterConfig={{ items: filterConfigItems(isWorkspaceEnabled) }}
        activeFiltersConfig={activeFiltersConfig}
      />
      {sigDetailsTableLoading ? (
        <SkeletonTable
          rows={tableVars.limit}
          columns={columns.map((column) => column.title)}
        />
      ) : (
        <Table
          className="sigTable"
          aria-label="Signature Details table"
          rows={rows}
          cells={columns}
          onCollapse={onCollapse}
          onSort={onSort}
          sortBy={
            sigDetailsTable?.data?.rulesList[0]?.affectedHosts?.totalCount > 0
              ? sortBy
              : undefined
          }
          isStickyHeader
        >
          <TableHeader />
          <TableBody />
        </Table>
      )}

      {!sigDetailsTable?.error &&
      !sigDetailsTableLoading &&
      affectedCount !== 0 ? (
        sigDetailsTable?.data?.rulesList[0]?.affectedHosts?.totalCount === 0 ? (
          NoResultsMatch
        ) : (
          <React.Fragment />
        )
      ) : (
        !sigDetailsTableLoading &&
        (isEmptyAccount ? EmptyAccountState : NoAffectedHosts)
      )}
      {sigDetailsTable?.error && <ErrorState />}
      <TableToolbar isFooter>
        <Pagination
          itemCount={
            sigDetailsTable?.data?.rulesList[0]?.affectedHosts?.totalCount || 0
          }
          widgetId="pagination-options-menu-bottom"
          perPage={tableVars.limit}
          page={page}
          variant={PaginationVariant.bottom}
          onSetPage={onSetPage}
          onPerPageSelect={onPerPageSelect}
        />
      </TableToolbar>
    </React.Fragment>
  );
};

NewSigDetailsTable.propTypes = {
  ruleName: propTypes.string,
  affectedCount: propTypes.number,
  isEmptyAccount: propTypes.bool,
};

export default NewSigDetailsTable;
