/* eslint-disable no-unused-vars */
import './SigTable.scss';

import { Pagination, PaginationVariant } from '@patternfly/react-core/dist/esm/components/Pagination/index';
import React, { useEffect, useReducer, useState } from 'react';
import {
    SortByDirection,
    Table,
    TableBody,
    TableHeader,
    cellWidth,
    classNames,
    expandable,
    sortable
} from '@patternfly/react-table/dist/esm/components/Table/index';
import { gqlProps } from '../Common';
import { DateFormat } from '@redhat-cloud-services/frontend-components/DateFormat';
import { GET_SIGNATURE_TABLE } from '../../operations/queries';
import { DISABLE_SIGNATURES, ENABLE_SIGNATURES } from '../../operations/mutations';
import MessageState from '../MessageState/MessageState';
import { PrimaryToolbar } from '@redhat-cloud-services/frontend-components/PrimaryToolbar';
import { SearchIcon } from '@patternfly/react-icons/dist/esm/icons/search-icon';
import StatusLabel from '../StatusLabel/StatusLabel';
import { Tooltip } from '@patternfly/react-core/dist/esm/components/Tooltip/Tooltip';
import { Label } from '@patternfly/react-core/dist/esm/components/Label';
import messages from '../../Messages';
import { sigTableFilters } from '../../store/cache';
import { useIntl } from 'react-intl';
import { useMutation, useQuery } from '@apollo/client';
import { useReactiveVar } from '@apollo/client';
import SignatureDescription from './SignatureDescription';
import InsightsLink from '@redhat-cloud-services/frontend-components/InsightsLink';
import { SkeletonTable } from '@redhat-cloud-services/frontend-components/SkeletonTable';

const initialState = {
    tableVars: {
        limit: 10,
        offset: 0,
        orderBy: ['LAST_MATCH_DATE_NULLS_LAST_DESC', 'NAME_ASC'],
        ruleName: ''
    },
    sortBy: {
        index: 5,
        direction: SortByDirection.desc
    },
    rows: [],
    selectedSigs: []
};
const sortIndices = { 2: 'NAME', 3: 'HAS_MATCH', 4: 'HOST_COUNT', 5: 'LAST_MATCH_DATE_NULLS_LAST' };
const orderBy = ({ index, direction }) => {
    const orderByVariable = `${sortIndices[index]}_${direction === SortByDirection.asc ? 'ASC' : 'DESC'}`;
    // Additionally orderBy signature name to add more determinism to the order of the table rows
    return sortIndices[index] !== 'NAME' ? [orderByVariable, 'NAME_ASC'] : orderByVariable;
};

const tableReducer = (state, action) => {
    switch (action.type) {
        case 'setTableVars':
            return { ...state, tableVars: { ...state.tableVars, ...action.payload } };
        case 'setSortBy':
            return { ...state, sortBy: action.payload, tableVars: { ...state.tableVars, ...action.tableVars } };
        case 'setRows':
            return { ...state, rows: action.payload };
        case 'setSelectedSigs':
            return { ...state, selectedSigs: action.payload };
    }

    return state;
};

const SigTable = ({ refetchSigPageData }) => {
    const intl = useIntl();
    const [{ tableVars, sortBy, rows, selectedSigs }, stateSet] = useReducer(tableReducer, {
        ...initialState
    });
    const [showTable, setShowTable] = useState(false);
    const { data: sigTableData, loading: sigTableLoading, error: sigTableError, client } =
        useQuery(GET_SIGNATURE_TABLE, { variables: { ...tableVars, ...useReactiveVar(sigTableFilters) } });
    const mutationVars = {
        variables: { input: { id: selectedSigs.map(sig => sig.id) } },
        onCompleted: () => {
            setShowTable(false);  // don't display the sig table rows whilst we are refetching the data
            client.resetStore();  // clear the query cache so we must refetch all new data
            refetchSigPageData(); // updates the StatusCard component and hasMalware flag (on the same page as SigTable)
            stateSet({ type: 'setSelectedSigs', payload: [] }); // unselect any sigs that were selected
        }
    };
    const [enableSignature, { loading: enableSigLoading }] = useMutation(ENABLE_SIGNATURES, mutationVars);
    const [disableSignature, { loading: disableSigLoading }] = useMutation(DISABLE_SIGNATURES, mutationVars);

    const columns = [
        { title: intl.formatMessage(messages.sigName), cellFormatters: [expandable], transforms: [sortable, cellWidth(45)] },
        { title: intl.formatMessage(messages.lastStatus), transforms: [cellWidth(10), sortable] },
        { title: intl.formatMessage(messages.systems), transforms: [cellWidth(10), sortable] },
        { title: intl.formatMessage(messages.lastMatched), transforms: [cellWidth(10), sortable] }
    ];

    const page = tableVars.offset / tableVars.limit + 1;
    const sigTableFiltersInitialState =  {
        items: { hasMatch: 'true', isDisabled: [] },
        condition: { hasMatch: true, isDisabled: undefined }
    };

    const updateSelectedSigs = ((selectedRows, selected) => {
        // This function handles adding/removing sigs to/from the selectedSigs when rows are selected/unselected
        const rowSigIds = selectedRows.map(row => row.sigData.id);
        // remove sigs from the list when unselecting, but also prevents duplicate selectedSigs when adding
        const filteredSigs = selectedSigs.filter(sig => !rowSigIds.includes(sig.id));
        if (selected) {
            // add the new selected sigs to the existing list of selectedSigs
            return [...filteredSigs, ...selectedRows.map(sig =>
                ({ id: sig.sigData.id, name: sig.sigData.name, isDisabled: sig.sigData.isDisabled }))];
        } else {
            return filteredSigs;
        }
    });

    const onSelect = (event, selected, rowKey) => {
        let selectedRows = [...rows];
        let updatedSelectedSigs;
        if (rowKey === -1) {
            // All the rows were selected
            // However rows are actually in groups of 2 - row 1: rule match details, row 2: rule description (hidden by default),
            // So only set the first row in each group to selected (not the hidden row too)
            selectedRows = selectedRows.map((item, key) => key % 2 === 0 ? { ... item, selected } : { ...item });
            updatedSelectedSigs = updateSelectedSigs(selectedRows.filter((item, key) => key % 2 === 0), selected);
        } else {
            selectedRows[rowKey] = { ...selectedRows[rowKey], selected };
            updatedSelectedSigs = updateSelectedSigs([selectedRows[rowKey]], selected);
        }

        stateSet({ type: 'setRows', payload: selectedRows });
        stateSet({ type: 'setSelectedSigs', payload: updatedSelectedSigs });
    };

    const onCollapse = (e, rowKey, isOpen) => {
        const collapseRows = [...rows];
        const sig = collapseRows[rowKey].sigData;

        collapseRows[rowKey] = { ...collapseRows[rowKey], isOpen };
        collapseRows[rowKey + 1].cells = [{
            title: <SignatureDescription signature={sig} />
        }];
        stateSet({ type: 'setRows', payload: collapseRows });
    };

    const actionResolver = (rowData, { rowIndex }) => {
        const sig = rows[rowIndex].sigData || null;
        if (sig) {
            const newMutationVars = { ...mutationVars, variables: { input: { id: sig.id } } };
            return sig.isDisabled ?
                [{
                    title: intl.formatMessage(messages.enableSignatureForAnalysis),
                    onClick: () => enableSignature(newMutationVars)
                }] : [{
                    title: intl.formatMessage(messages.disableSignatureFromAnalysis),
                    onClick: () => disableSignature(newMutationVars)
                }];
        }
    };

    const toolbarActions = [
        '', // intentionally left blank so a button isn't displayed next to the kebab on the toolbar
        {
            label: intl.formatMessage(messages.enableSignaturesForAnalysis),
            onClick: () => enableSignature(mutationVars),
            props: { isDisabled: selectedSigs.filter((sig) => sig.isDisabled).length === 0 }
        }, {
            label: intl.formatMessage(messages.disableSignaturesFromAnalysis),
            onClick: () => disableSignature(mutationVars),
            props: { isDisabled: selectedSigs.filter((sig) => !sig.isDisabled).length === 0 }
        }];

    const FILTER_CATEGORIES = {
        sig_match: {
            type: 'radio', title: intl.formatMessage(messages.status), urlParam: 'sig_match', values: [
                { label: intl.formatMessage(messages.all), value: 'all' },
                { label: intl.formatMessage(messages.matched), value: 'true' },
                { label: intl.formatMessage(messages.notMatched), value: 'false' }
            ]
        },
        sigs_included: {
            type: 'checkbox', title: intl.formatMessage(messages.signaturesIncludedFilter), urlParam: 'sigs_included', values: [
                { label: intl.formatMessage(messages.enabledSignatures), value: 'false' },  // isDisabled: false
                { label: intl.formatMessage(messages.disabledSignatures), value: 'true' }   // isDisabled: true
            ]
        }
    };
    const filterConfigItems = [{
        label: FILTER_CATEGORIES.sigs_included.title.toLowerCase(),
        type: FILTER_CATEGORIES.sigs_included.type,
        id: FILTER_CATEGORIES.sigs_included.urlParam,
        filterValues: {
            key: `${FILTER_CATEGORIES.sigs_included.urlParam}-filter`,
            onChange: (e, value) => {
                const tableFilters = sigTableFilters();
                sigTableFilters({
                    items: { ...tableFilters.items, isDisabled: value },
                    condition: { ...tableFilters.condition, isDisabled: (value.length !== 1) ? undefined : JSON.parse(value[0]) }
                });
            },
            value: sigTableFilters().items?.isDisabled || ['false'],
            items: FILTER_CATEGORIES.sigs_included.values
        }
    }, {
        label: intl.formatMessage(messages.signature).toLowerCase(),
        filterValues: {
            key: 'text-filter',
            onChange: (e, value) => stateSet({ type: 'setTableVars', payload: { ruleName: value, offset: 0 } }),
            value: tableVars.ruleName,
            placeholder: intl.formatMessage(messages.filterBy, { field: intl.formatMessage(messages.signature).toLowerCase() })
        }
    }, {
        label: FILTER_CATEGORIES.sig_match.title.toLowerCase(),
        type: FILTER_CATEGORIES.sig_match.type,
        id: FILTER_CATEGORIES.sig_match.urlParam,
        value: `radio-${FILTER_CATEGORIES.sig_match.urlParam}`,
        filterValues: {
            key: `${FILTER_CATEGORIES.sig_match.urlParam}-filter`,
            onChange: (e, value) => {
                const tableFilters = sigTableFilters();
                sigTableFilters({
                    items: { ...tableFilters.items, hasMatch: value },
                    condition: { ...tableFilters.condition, hasMatch: (value === 'all') ? undefined : JSON.parse(value) }
                });
            },
            value: sigTableFilters().items?.hasMatch || 'true',
            items: FILTER_CATEGORIES.sig_match.values
        }
    }];

    const onSetPage = (e, page) => stateSet({ type: 'setTableVars', payload: { offset: page * tableVars.limit - tableVars.limit } });

    const onPerPageSelect = (e, perPage) => stateSet({ type: 'setTableVars', payload: { limit: perPage, offset: 0 } });

    const onSort = (e, index, direction) =>
        stateSet({ type: 'setSortBy', payload: { index, direction }, tableVars: { orderBy: orderBy({ index, direction }), offset: 0 } });

    const setMatchedFilterChips = ({ event, chips = [] }) => {
        // Add/remove chips for the Status filter & set the radio button value and API query variable accordingly
        const tableFilters = sigTableFilters();
        if (event === 'add') {
            let matchedMessage = intl.formatMessage(messages.all);
            if (tableFilters.items?.hasMatch === 'true') {
                matchedMessage = intl.formatMessage(messages.matched);
            } else if (tableFilters.items?.hasMatch === 'false') {
                matchedMessage = intl.formatMessage(messages.notMatched);
            }

            chips.push({
                category: intl.formatMessage(messages.status), value: 'matched',
                chips: [{ name: matchedMessage, value: matchedMessage }]
            });
        } else if (event === 'remove') {
            const [newValue, newCondition] = (tableFilters.items?.hasMatch === 'all') ?
                ['true', true] : ['all', undefined];
            sigTableFilters({
                items: { ...tableFilters.items, hasMatch: newValue },
                condition: { ...tableFilters.condition, hasMatch: newCondition }
            });
        }
    };

    const setIncludedFilterChips = ({ event, chips = [], item = '' }) => {
        // Add/remove chips for the Signatures included filter & set the checkbox values and API query variable accordingly
        const tableFilters = sigTableFilters();
        if (event === 'add') {
            const includedFilters = [];
            tableFilters.items?.isDisabled.map((val) => {
                const includedMessage = intl.formatMessage(val === 'true' ? messages.disabledSignatures : messages.enabledSignatures);
                includedFilters.push({ name: includedMessage, value: includedMessage });
            });
            chips.push({ category: intl.formatMessage(messages.signaturesIncludedFilter), chips: includedFilters });

        } else if (event === 'remove') {
            let [newValue, newCondition] = [[], undefined];
            if (tableFilters.items?.isDisabled.length !== 1) {
                [newValue, newCondition] = (item.value === intl.formatMessage(messages.enabledSignatures)) ?
                    [['true'], true] : [['false'], false];
            }

            sigTableFilters({
                items: { ...tableFilters.items, isDisabled: newValue },
                condition: { ...tableFilters.condition, isDisabled: newCondition }
            });
        }
    };

    const buildFilterChips = () => {
        const chips = [];
        tableVars?.ruleName &&
            chips.push({
                category: intl.formatMessage(messages.signature), value: 'name',
                chips: [{ name: tableVars?.ruleName, value: tableVars?.ruleName }]
            });
        setMatchedFilterChips({ event: 'add', chips });
        setIncludedFilterChips({ event: 'add', chips });
        return chips;
    };

    const activeFiltersConfig = {
        deleteTitle: intl.formatMessage(messages.resetFilters),
        filters: buildFilterChips(),
        showDeleteButton: true,
        onDelete: (event, itemsToRemove, isAll) => {
            if (isAll) {
                sigTableFilters(sigTableFiltersInitialState);
                stateSet({ type: 'setTableVars', payload: { ruleName: '' } });
            } else {
                itemsToRemove.map((item) => {
                    item.value === 'name' && stateSet({ type: 'setTableVars', payload: { ruleName: '' } });
                    item.value === 'matched' && setMatchedFilterChips({ event: 'remove' });
                    !(item.value === 'name' || item.value === 'matched') && setIncludedFilterChips({ event: 'remove', item });
                });
            }
        }
    };

    useEffect(() => {
        sigTableFilters(sigTableFiltersInitialState);
    }, []);

    useEffect(() => {
        // A hack to reset the SigTable page offset to the first page whenever the filters change
        // This is because clicking on the StatusCard links doesn't refresh the pagination start page in the SigTable
        // There may be a better way to handle this, but this is all I could come up with
        stateSet({ type: 'setTableVars', payload: { offset: 0 } });
    }, [sigTableFilters().condition]);

    useEffect(() => {
        const selectedSigIds = selectedSigs.map(sig => sig.id);
        const rowBuilder = data => data?.rulesList?.flatMap((data, key) => {
            const sig = data;
            return [{
                rowId: key,
                isOpen: false,
                sigData: sig,
                selected: selectedSigIds.includes(sig.id),
                cells: [
                    { title:
                        <React.Fragment>
                            <InsightsLink to={`/signatures/${sig.name}`}>{sig.name}</InsightsLink>
                            {sig.isDisabled &&
                                <React.Fragment>
                                    <br />
                                    <Label color='red' isCompact>{intl.formatMessage(messages.disabled)}</Label>
                                </React.Fragment>
                            }
                        </React.Fragment>
                    },
                    { title: sig.isDisabled ? intl.formatMessage(messages.notApplicable) :
                        <StatusLabel isDisabled={sig.isDisabled} hasMatch={sig.hasMatch} displayMatch/>
                    },
                    { title: sig.isDisabled ? intl.formatMessage(messages.notApplicable) :
                        <InsightsLink to={`/signatures/${sig.name}`}>{sig.hostCount?.toLocaleString()}</InsightsLink>
                    },
                    { title: sig.isDisabled ? intl.formatMessage(messages.notApplicable) :
                        sig.lastMatchDate ?
                            <Tooltip content={<DateFormat date={new Date(sig.lastMatchDate)} type='exact' />}>
                                <span><DateFormat date={new Date(sig.lastMatchDate)} /></span>
                            </Tooltip>
                            : <Tooltip content={intl.formatMessage(messages.noHostHas)}>
                                <span>{intl.formatMessage(messages.never)}</span>
                            </Tooltip>
                    }
                ]
            }, {
                parent: key * 2,
                fullWidth: true,
                cells: []
            }];
        });

        stateSet({ type: 'setRows', payload: rowBuilder(sigTableData) });
        setShowTable(true);
    }, [intl, sigTableData]);

    return <React.Fragment>
        <PrimaryToolbar
            pagination={{
                itemCount: sigTableData?.rules?.totalCount || 0,
                page,
                perPage: tableVars.limit,
                onSetPage(e, page) { onSetPage(e, page); },
                onPerPageSelect(e, perPage) { onPerPageSelect(e, perPage); },
                isCompact: true
            }}
            filterConfig={{ items: filterConfigItems }}
            activeFiltersConfig={activeFiltersConfig}
            actionsConfig={{
                actions: toolbarActions,
                dropdownProps: { ouiaId: 'toolbar-actions' }
            }}
        />
        {enableSigLoading || disableSigLoading || !showTable
            ? <SkeletonTable
                columns={[{ title: '', columnTransforms: [classNames('skeleton-expandable-column')] }, ...columns]}
                rowSize={tableVars.limit}
                sortBy={sortBy}
                isSelectable={true}
            />
            : <Table
                className='sigTable'
                aria-label='Signature table'
                onCollapse={onCollapse}
                rows={rows}
                cells={columns}
                onSort={onSort}
                sortBy={sigTableData?.rulesList?.length > 0 ? sortBy : undefined}
                isStickyHeader
                canSelectAll={true}
                onSelect={onSelect}
                actionResolver={actionResolver}
            >
                <TableHeader />
                <TableBody />
            </Table>
        }

        {!sigTableLoading && !sigTableError && sigTableData?.rules?.totalCount === 0 &&
            <MessageState className='pf-c-card' icon={SearchIcon} variant='large' title={intl.formatMessage(messages.noResults)}
                text={intl.formatMessage(messages.noResultsMatch)} />}
        {sigTableError && <MessageState className='pf-c-card' variant='large' title='Error' text='error' />}
        <Pagination
            itemCount={sigTableData?.rules?.totalCount || 0}
            widgetId='pagination-options-menu-bottom'
            perPage={tableVars.limit}
            page={page}
            variant={PaginationVariant.bottom}
            onSetPage={onSetPage}
            onPerPageSelect={onPerPageSelect}
        />
    </React.Fragment>;
};

SigTable.propTypes = gqlProps;

export default SigTable;
