import React, { useEffect, useState } from 'react';
import { useApolloClient } from '@apollo/client';
import PropTypes from 'prop-types';
import { Table, Thead, Th, Tbody, Tr } from '@patternfly/react-table';
import { GET_HITS_TABLE } from '../../operations/queries';
import { SkeletonTable } from '@patternfly/react-component-groups';
import { NewMatchesTableRow } from './NewMatchesTableRow';

export const NewMatchesTable = ({
  fetchDetailsTable,
  hasWriteAccess,
  hostId,
  isExpanded,
  isWriteAccessLoading,
  matchStatusFilter,
  ruleName,
  setSelectedMatches,
}) => {
  const client = useApolloClient();
  const [areMatchesLoading, setAreMatchesLoading] = useState(false);
  const [hitlistData, setHitlistData] = useState([]);
  const columnNames = {
    blank: { name: '', width: 5 },
    scanDate: { name: 'Match date', width: 20 },
    matchedStatus: { name: 'Match status', width: 20 },
    note: { name: 'Note', width: 50 },
    actions: { name: '', width: 5 },
  };

  const fetchMatches = async () => {
    setAreMatchesLoading(true);
    try {
      const response = await client.query({
        query: GET_HITS_TABLE,
        fetchPolicy: 'no-cache',
        variables: {
          ruleName: ruleName,
          hostId: hostId,
          status: matchStatusFilter,
        },
      });

      setHitlistData(response.data.hitsList);
    } catch (error) {
      console.error('Error fetching data:', error);
    }
    setAreMatchesLoading(false);
  };

  useEffect(() => {
    if (isExpanded) {
      fetchMatches();
    }
  }, [isExpanded, matchStatusFilter]);

  return areMatchesLoading ? (
    <SkeletonTable rows={5} columns={Object.values(columnNames).length} />
  ) : (
    <Table
      style={{ marginTop: '16px', marginBottom: '16px' }}
      aria-label="Simple table"
      variant="compact"
    >
      <Thead style={{ borderBottom: '1px solid #d2d2d2' }}>
        <Tr>
          {Object.values(columnNames).map((column, idx) => (
            <Th
              aria-label={`${column.name} Header`}
              key={`column-title-${column.name}-${idx}`}
              width={column.width}
            >
              {column.name}
            </Th>
          ))}
        </Tr>
      </Thead>
      <Tbody>
        {hitlistData?.map((data, idx) => (
          <NewMatchesTableRow
            key={`${data.id}-row`}
            columnNames={columnNames}
            data={data}
            fetchDetailsTable={fetchDetailsTable}
            fetchMatches={fetchMatches}
            hasWriteAccess={hasWriteAccess}
            hostId={hostId}
            isWriteAccessLoading={isWriteAccessLoading}
            rowIndex={idx}
            setSelectedMatches={setSelectedMatches}
          />
        ))}
      </Tbody>
    </Table>
  );
};

NewMatchesTable.propTypes = {
  fetchDetailsTable: PropTypes.func,
  hasWriteAccess: PropTypes.bool,
  hostId: PropTypes.string,
  isExpanded: PropTypes.bool,
  isWriteAccessLoading: PropTypes.bool,
  matchStatusFilter: PropTypes.object,
  ruleName: PropTypes.string,
  setSelectedMatches: PropTypes.func,
};
