import React, { useCallback, useState } from 'react';
import { useMutation } from '@apollo/client';
import PropTypes from 'prop-types';
import { ActionsColumn, Tr, Td } from '@patternfly/react-table';
import { DELETE_MATCH, EDIT_MATCH } from '../../operations/mutations';
import { addRemoveItemInArray } from '../helpers';
import { DropdownBasic } from './DropdownBasic';
import { TextInputBasic } from './TextInputBasic';
import { filterValues } from '../constants';
import { useVerifyInput } from '../useVerifyInput';
import { MatchedDateColumn } from './MatchedDateColumn';

export const NewMatchesTableRow = ({
  columnNames,
  data,
  fetchDetailsTable,
  fetchMatches,
  hasWriteAccess,
  hostId,
  isWriteAccessLoading,
  rowIndex,
  setSelectedMatches,
}) => {
  const [isSelected, setIsSelected] = useState(false);
  const [textValue, setTextValue] = useState(data.justification);
  const [dropdownValue, setDropdownValue] = useState(data.status);
  const [deleteMatch] = useMutation(DELETE_MATCH, {
    variables: { input: [data.id] },
  });
  const [executeMutation] = useMutation(EDIT_MATCH);

  const onSelectMatch = (data) => {
    setIsSelected(!isSelected);
    setSelectedMatches((prev) => {
      return addRemoveItemInArray(prev, data.id);
    });
  };

  const onDeleteMatch = async () => {
    await deleteMatch();
    await fetchDetailsTable(false);
    await fetchMatches(hostId);
  };

  //TODO:For error handling, only setDropdownValue to anything AFTER the mutation executes succesfully
  const handleDropdownChange = useCallback(
    (newDropdownValue) => {
      // Only call mutation if the dropdown value has changed
      if (newDropdownValue !== null && newDropdownValue !== dropdownValue) {
        setDropdownValue(newDropdownValue);
        executeMutation({
          variables: {
            input: {
              sourceHitId: data.id,
              status: newDropdownValue,
              justification: textValue,
            },
          },
        });

        // if the status of a match is changed to Not reviewed or from Not reviewed to any other status, then we call fetchDetailsTable to update the New matches column in the parent table
        if (
          (newDropdownValue === 'NOT_REVIEWED' &&
            dropdownValue !== 'NOT_REVIEWED') ||
          (newDropdownValue !== 'NOT_REVIEWED' &&
            dropdownValue === 'NOT_REVIEWED')
        ) {
          fetchDetailsTable(false);
        }
      }
    },
    [executeMutation, data.id, dropdownValue, textValue]
  );

  // Debounced execute mutation for text input changes
  const memoizedExecuteMutation = useCallback(() => {
    executeMutation({
      variables: {
        input: {
          sourceHitId: data.id,
          status: dropdownValue,
          justification: textValue,
        },
      },
    });
  }, [executeMutation, data.id, textValue]);

  // Hook to perform verification on text input change
  const verifiedStatus = useVerifyInput(textValue, memoizedExecuteMutation);
  const isLoading = verifiedStatus === 'loading';

  return (
    <Tr>
      <Td
        select={{
          rowIndex,
          onSelect: () => onSelectMatch(data),
          isSelected: isSelected,
          isDisabled: !isWriteAccessLoading && !hasWriteAccess,
        }}
      />
      <Td dataLabel={columnNames.scanDate.name}>
        <MatchedDateColumn data={data} dropdownValue={dropdownValue} />
      </Td>
      <Td style={{ maxWidth: '100px' }}>
        <DropdownBasic
          dropdownValue={dropdownValue}
          dropdownValues={filterValues}
          hasWriteAccess={hasWriteAccess}
          isWriteAccessLoading={isWriteAccessLoading}
          onChange={handleDropdownChange}
          setDropdownValue={setDropdownValue}
        />
      </Td>
      <Td>
        <TextInputBasic
          hasWriteAccess={hasWriteAccess}
          isLoading={isLoading}
          isWriteAccessLoading={isWriteAccessLoading}
          setTextValue={setTextValue}
          textValue={textValue}
          verifiedStatus={verifiedStatus}
        />
      </Td>
      {!isWriteAccessLoading && hasWriteAccess && (
        <Td style={{ textAlign: 'right' }}>
          <ActionsColumn
            items={[{ title: 'Delete match', onClick: () => onDeleteMatch() }]}
          />
        </Td>
      )}
    </Tr>
  );
};

NewMatchesTableRow.propTypes = {
  columnNames: PropTypes.object,
  data: PropTypes.object,
  fetchDetailsTable: PropTypes.func,
  fetchMatches: PropTypes.func,
  hasWriteAccess: PropTypes.bool,
  hostId: PropTypes.string,
  isWriteAccessLoading: PropTypes.bool,
  rowIndex: PropTypes.number,
  setSelectedMatches: PropTypes.func,
};
