import React, { useCallback, useState } from 'react';
import { useMutation } from '@apollo/client';
import PropTypes from 'prop-types';
import { ActionsColumn, Tr, Td } from '@patternfly/react-table';
import { DELETE_MATCH, EDIT_MATCH } from '../../operations/mutations';
import { updateArray } from '../helpers';
import { DropdownBasic } from './DropdownBasic';
import { TextInputBasic } from './TextInputBasic';
import { filterValues } from '../constants';
import { useVerifyInput } from '../useVerifyInput';

import { MatchedDateColumn } from './MatchedDateColumn';

export const NewMatchesTableRow = ({
  columnNames,
  data,
  fetchDetailsTable,
  fetchMatches,
  hostId,
  rowIndex,
  setSelectedMatches,
}) => {
  const [isSelected, setIsSelected] = useState(false);
  const [textValue, setTextValue] = useState(data.justification);
  const [dropdownValue, setDropdownValue] = useState(data.status);
  const [deleteMatch] = useMutation(DELETE_MATCH, {
    variables: { input: [data.id] },
  });
  const [executeMutation] = useMutation(EDIT_MATCH);

  const onSelectMatch = (data) => {
    setIsSelected(!isSelected);
    setSelectedMatches((prev) => {
      return updateArray(prev, data.id);
    });
  };

  const onDeleteMatch = async () => {
    await deleteMatch();
    await fetchDetailsTable(false);
    await fetchMatches(hostId);
  };

  //when i type fresh, and then do dropdown, textValue is null
  const handleDropdownChange = useCallback(
    (newDropdownValue) => {
      // Only call mutation if the dropdown value has changed
      if (newDropdownValue !== null && newDropdownValue !== dropdownValue) {
        setDropdownValue(newDropdownValue);
        executeMutation({
          variables: {
            input: {
              sourceHitId: data.id,
              status: newDropdownValue,
              justification: textValue,
            },
          },
        });
      }
    },
    [executeMutation, data.id, dropdownValue, textValue]
  );

  // Debounced execute mutation for text input changes
  const memoizedExecuteMutation = useCallback(() => {
    executeMutation({
      variables: {
        input: {
          sourceHitId: data.id,
          status: dropdownValue,
          justification: textValue,
        },
      },
    });
  }, [executeMutation, data.id, textValue]);

  // Hook to perform verification on text input change
  const verifiedStatus = useVerifyInput(textValue, memoizedExecuteMutation);
  const isLoading = verifiedStatus === 'loading';

  //TODO: Make the blue stuff its own component and render that based if dropdown is NOT REVIEWD
  return (
    <Tr>
      <Td
        select={{
          rowIndex,
          onSelect: () => onSelectMatch(data),
          isSelected: isSelected,
        }}
      />
      <Td dataLabel={columnNames.scanDate.name}>
        <MatchedDateColumn data={data} dropdownValue={dropdownValue} />
      </Td>
      <Td style={{ maxWidth: '100px' }}>
        <DropdownBasic
          dropdownValue={dropdownValue}
          dropdownValues={filterValues}
          onChange={handleDropdownChange}
          setDropdownValue={setDropdownValue}
        />
      </Td>
      <Td>
        <TextInputBasic
          textValue={textValue}
          setTextValue={setTextValue}
          verifiedStatus={verifiedStatus}
          isLoading={isLoading}
        />
      </Td>
      <Td style={{ textAlign: 'right' }}>
        <ActionsColumn
          items={[{ title: 'Delete match', onClick: () => onDeleteMatch() }]}
        />
      </Td>
    </Tr>
  );
};

NewMatchesTableRow.propTypes = {
  columnNames: PropTypes.object,
  data: PropTypes.object,
  fetchDetailsTable: PropTypes.func,
  fetchMatches: PropTypes.func,
  hostId: PropTypes.string,
  rowIndex: PropTypes.number,
  setSelectedMatches: PropTypes.func,
};
